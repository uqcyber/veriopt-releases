<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory CanonicalizationSyntax</title>
</head>


<body>
<div class="head">
<h1>Theory CanonicalizationSyntax</h1>
</div>

<pre class="source"><span class="keyword1"><span class="command">theory</span></span> CanonicalizationSyntax
<span class="keyword2"><span class="keyword">imports</span></span> <a href="CanonicalizationTreeProofs.html">CanonicalizationTreeProofs</a>
<span class="keyword2"><span class="keyword">keywords</span></span>
  <span class="quoted">"phase"</span> <span class="main">::</span> thy_decl <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted">"optimization"</span> <span class="main">::</span> thy_goal_defn <span class="keyword2"><span class="keyword">and</span></span>
  <span class="quoted">"print_optimizations"</span> <span class="main">::</span> diag
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">size</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"IRExpr <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>UnaryExpr <span class="free"><span class="bound"><span class="entity">op</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>BinaryExpr BinAdd <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">*</span> <span class="numeral">2</span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>BinaryExpr <span class="free"><span class="bound"><span class="entity">op</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>ConditionalExpr <span class="free"><span class="bound"><span class="entity">cond</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">cond</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">size</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="numeral">2</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>ConstantExpr <span class="free"><span class="bound"><span class="entity">const</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>ParameterExpr <span class="free"><span class="bound"><span class="entity">ind</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>LeafExpr <span class="free"><span class="bound"><span class="entity">nid</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>ConstantVar <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">size</span> <span class="main">(</span>VariableExpr <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> size_gt_0<span class="main">:</span> <span class="quoted"><span class="quoted">"size <span class="free">e</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>UnaryExpr <span class="skolem">x1</span> <span class="skolem">e</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
<span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>BinaryExpr <span class="skolem">x1</span> <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x1</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ConditionalExpr <span class="skolem">e1</span> <span class="skolem">e2</span> <span class="skolem">e3</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ParameterExpr <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span>
<span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LeafExpr <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ConstantExpr <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ConstantVar <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>VariableExpr <span class="skolem">x1</span> <span class="skolem">x2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> binary_expr_size_gte_2<span class="main">:</span> <span class="quoted"><span class="quoted">"size <span class="main">(</span>BinaryExpr <span class="free">op</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">≥</span> <span class="numeral">2</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"BinaryExpr <span class="free">op</span> <span class="free">x</span> <span class="free">y</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">op</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> size_gt_0
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_leI add_le_mono mult_2_right numeral_Bit0 numeral_code<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> trans_le_add2<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_leI add_2_eq_Suc' add_Suc_shift add_mono numeral_2_eq_2 size_gt_0<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"size <span class="free">e</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> is_ConstantExpr <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> size_gt_0
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_numeral_extra<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> size_gt_0
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> binary_expr_size_gte_2 lessI not_less numeral_2_eq_2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nonconstants_gt_one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span>is_ConstantExpr <span class="free">e</span><span class="main">)</span> <span class="main">⟹</span> size <span class="free">e</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> size_gt_0
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">using</span></span> size_gt_0
  <span class="keyword1"><span class="command">using</span></span> Suc_le_eq binary_expr_size_gte_2 numeral_2_eq_2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> size_det<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">⟹</span> size <span class="free">x</span> <span class="main">=</span> size <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> Rewrite <span class="main">=</span>
  Transform <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">|</span>
  Conditional <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"bool"</span></span> <span class="main">|</span>
  Sequential <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Rewrite"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Rewrite"</span></span> <span class="main">|</span>
  Transitive <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> Rewrite"</span></span>


<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Transform <span class="free">a</span> <span class="free">a</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Conditional <span class="free">a</span> <span class="free">b</span> <span class="free">c</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Sequential <span class="free">a</span> <span class="free">b</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"Transitive <span class="free">a</span>"</span><span class="antiquote">}</span></span>›</span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">rewrite_obligation</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"IRExpr Rewrite <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rewrite_obligation</span> <span class="main">(</span>Transform <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rewrite_obligation</span> <span class="main">(</span>Conditional <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">cond</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">cond</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rewrite_obligation</span> <span class="main">(</span>Sequential <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">rewrite_obligation</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="free">rewrite_obligation</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">rewrite_obligation</span> <span class="main">(</span>Transitive <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">rewrite_obligation</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>


<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"rewrite_obligation <span class="free">a</span>"</span><span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">debugMode</span> <span class="main">=</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">debugPrint</span> <span class="entity">value</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">debugMode</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">print</span><span class="antiquote">}</span></span></span></span></span></span></span></span> <span class="entity">value</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">value</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">translateConst</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>Groups.plus_class.plus"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinAdd<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>Groups.minus_class.minus"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinSub<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>Groups.times_class.times"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinMul<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>HOL.conj"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinAnd<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>_binEquals"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinIntegerEquals<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>Groups.uminus_class.uminus"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> UnaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> UnaryNeg<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>Values.shiftl"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinLeftShift<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>Values.shiftr"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinRightShift<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>Values.sshiftr"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinURightShift<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Const <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">translateEquals</span> <span class="main">_</span> <span class="entity">terms</span> <span class="main">=</span>
  <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> BinIntegerEquals<span class="antiquote">}</span></span> $ hd <span class="entity">terms</span> $ hd <span class="main">(</span>tl <span class="entity">terms</span><span class="main">)</span>

<span class="comment1">(* A seemingly arbitrary distinction  *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">translateFree</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">(</span><span class="inner_quoted">"abs"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> UnaryExpr<span class="antiquote">}</span></span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> UnaryAbs<span class="antiquote">}</span></span>
    <span class="main">|</span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=&gt;</span> 
      <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> String.sub<span class="main">(</span><span class="entity">var</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">#"c"</span> 
        <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ConstantExpr<span class="antiquote">}</span></span> $ Free <span class="main">(</span><span class="inner_quoted">"val_"</span> ^ <span class="entity">var</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> Free <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">trm</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debugPrint</span> <span class="inner_quoted">"Expanding node"</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">debugPrint</span> <span class="entity">trm</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">of</span></span>
    Const <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">translateConst</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
    <span class="main">|</span> Free <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">translateFree</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
    <span class="main">|</span> Abs <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">trm</span><span class="main">)</span> <span class="main">=&gt;</span> Abs <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">typ</span><span class="main">,</span> <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">trm</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">e</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>IRTreeEval.IRExpr.ConstantExpr"</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span> $ <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">e</span>
    <span class="main">|</span> <span class="main">(</span><span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">x</span> $ <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">y</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">trm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">expandNodes</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">trm</span><span class="main">]</span> <span class="main">=</span> <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">trm</span>
  <span class="main">|</span> <span class="entity">expandNodes</span> <span class="main">_</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"expandNodes"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">baseTransform</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">pre</span><span class="main">,</span> <span class="entity">post</span><span class="main">]</span> <span class="main">=</span>
  Const
     <span class="main">(</span><span class="inner_quoted">"CanonicalizationSyntax.Rewrite.Transform"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"IRExpr <span class="main">=&gt;</span> IRExpr <span class="main">⇒</span> IRExpr Rewrite"</span><span class="antiquote">}</span></span><span class="main">)</span>
    $ <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">pre</span>
    $ <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">post</span>

  <span class="main">|</span> <span class="entity">baseTransform</span> <span class="main">_</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"baseTransform"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conditionTransform</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">pre</span><span class="main">,</span> <span class="entity">post</span><span class="main">,</span> <span class="entity">cond</span><span class="main">]</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="inner_quoted">"CanonicalizationSyntax.Rewrite.Conditional"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"IRExpr <span class="main">⇒</span> IRExpr <span class="main">⇒</span> bool <span class="main">⇒</span> IRExpr Rewrite"</span><span class="antiquote">}</span></span><span class="main">)</span>
    $ <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">pre</span>
    $ <span class="entity">expandNode</span> <span class="entity">ctxt</span> <span class="entity">post</span>
    $ <span class="entity">cond</span>

  <span class="main">|</span> <span class="entity">conditionTransform</span> <span class="main">_</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"conditionTransform"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">constantValues</span> <span class="main">_</span> <span class="main">[</span><span class="entity">trm</span><span class="main">]</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">trm</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">c</span> <span class="keyword1"><span class="keyword">as</span></span> Const <span class="main">_</span> <span class="main">=&gt;</span>
      <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ConstantExpr<span class="antiquote">}</span></span> $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> IntVal32<span class="antiquote">}</span></span> $ <span class="entity">c</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">x</span> $ <span class="entity">y</span> <span class="main">=&gt;</span> 
      <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ConstantExpr<span class="antiquote">}</span></span> $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> IntVal32<span class="antiquote">}</span></span> $ <span class="main">(</span><span class="entity">x</span> $ <span class="entity">y</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">trm</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">constantValues</span> <span class="main">_</span> <span class="entity">ts</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"constantValues"</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>

›</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_constantValues"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"term <span class="main">⇒</span> term"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">const</span> _"</span> 120<span class="main">)</span>
<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹ <span class="main">[</span><span class="main">(</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_constantValues"<span class="antiquote">}</span></span> <span class="main">,</span> <span class="entity">constantValues</span><span class="main">)</span><span class="main">]</span> ›</span>

<span class="keyword1"><span class="command">notation</span></span> ConditionalExpr <span class="main">(</span><span class="quoted">"_ <span class="keyword1">?</span> _ <span class="keyword1">:</span> _"</span><span class="main">)</span>
<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_binEquals"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"term <span class="main">⇒</span> term <span class="main">⇒</span> term"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">==</span> _"</span> 100<span class="main">)</span>
<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹ <span class="main">[</span><span class="main">(</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_binEquals"<span class="antiquote">}</span></span> <span class="main">,</span> <span class="entity">translateEquals</span><span class="main">)</span><span class="main">]</span> ›</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_expandNodes"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"term <span class="main">⇒</span> term"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">exp[</span>_<span class="keyword1">]</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹ <span class="main">[</span><span class="main">(</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_expandNodes"<span class="antiquote">}</span></span> <span class="main">,</span> <span class="entity">expandNodes</span><span class="main">)</span><span class="main">]</span> ›</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_baseTransform"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"term <span class="main">⇒</span> term <span class="main">⇒</span> term"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">↦</span> _"</span> 10<span class="main">)</span>
<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹ <span class="main">[</span><span class="main">(</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_baseTransform"<span class="antiquote">}</span></span> <span class="main">,</span> <span class="entity">baseTransform</span><span class="main">)</span><span class="main">]</span> ›</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="quoted">"_conditionalTransform"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"term <span class="main">⇒</span> term <span class="main">⇒</span> term <span class="main">⇒</span> term"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">↦</span> _ <span class="keyword1">when</span> _"</span> 70<span class="main">)</span>
<span class="keyword1"><span class="command">parse_translation</span></span> <span class="quoted">‹ <span class="main">[</span><span class="main">(</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_conditionalTransform"<span class="antiquote">}</span></span> <span class="main">,</span> <span class="entity">conditionTransform</span><span class="main">)</span><span class="main">]</span> ›</span>


<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">exp[</span>abs <span class="free">e</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"abs <span class="free">e</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">x</span> <span class="main">&amp;</span> <span class="free">x</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">cond</span> <span class="main">?</span> <span class="free">tv</span> <span class="main">:</span> <span class="free">fv</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">c</span> <span class="main">&lt;</span> <span class="free">y</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">a</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">&lt;</span> <span class="free">y</span>"</span><span class="antiquote">}</span></span>›</span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="free">x</span> <span class="main">&lt;&lt;</span> <span class="free">y</span>"</span><span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">exp[</span>c1 <span class="main">+</span> <span class="free">y</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">datatype</span></span> Type <span class="main">=</span>
  Integer <span class="main">|</span>
  Float <span class="main">|</span>
  Object <span class="main">|</span>
  Unknown

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">type</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"IRExpr <span class="main">⇒</span> Type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">type</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span>stamp_expr <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
    IntegerStamp <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Integer
    <span class="main">|</span> ObjectStamp <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Object
    <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> Unknown<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfold_type<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>type <span class="free">x</span> <span class="main">=</span> Integer<span class="main">)</span> <span class="main">=</span> is_IntegerStamp <span class="main">(</span>stamp_expr <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> type_def <span class="keyword1"><span class="command">using</span></span> is_IntegerStamp_def
  <span class="keyword1"><span class="command">using</span></span> Stamp.case_eq_if Stamp.disc<span class="main">(</span>1<span class="main">)</span> Type.distinct<span class="main">(</span>1<span class="main">)</span> Type.distinct<span class="main">(</span>3<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Stamp.case_eq_if<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">type_safe</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"IRExpr <span class="main">⇒</span> IRExpr <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">type_safe</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span> <span class="main">=</span> 
    <span class="main">(</span><span class="main">(</span>type <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="main">=</span> type <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> 
    <span class="main">∧</span> <span class="main">(</span>is_IntegerStamp <span class="main">(</span>stamp_expr <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> 
        <span class="main">⟶</span> <span class="main">(</span>stp_bits <span class="main">(</span>stamp_expr <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">=</span> stp_bits <span class="main">(</span>stamp_expr <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">int_and_equal_bits</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">int_and_equal_bits</span> <span class="main">(</span>IntVal32 <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">(</span>IntVal32 <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">int_and_equal_bits</span> <span class="main">(</span>IntVal64 <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">(</span>IntVal64 <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">int_and_equal_bits</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> False"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unfold_int_typesafe<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type <span class="free">e1</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"type_safe <span class="free">e1</span> <span class="free">e2</span> <span class="main">=</span> 
    <span class="main">(</span><span class="main">(</span>type <span class="free">e1</span> <span class="main">=</span> type <span class="free">e2</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span>stp_bits <span class="main">(</span>stamp_expr <span class="free">e1</span><span class="main">)</span> <span class="main">=</span> stp_bits <span class="main">(</span>stamp_expr <span class="free">e2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_IntegerStamp <span class="main">(</span>stamp_expr <span class="free">e1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms unfold_type <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> type_safe_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">experiment</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lemma</span></span> add_intstamp_prop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type <span class="free">x</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type_safe <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"type <span class="keyword1">exp[</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">]</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> type_def type_safe_def
  <span class="keyword1"><span class="command">using</span></span> stamp_expr.simps<span class="main">(</span>3<span class="main">)</span> stamp_binary.simps<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> is_IntegerStamp_def type_def unfold_type <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sub_intstamp_prop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type <span class="free">x</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type_safe <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"type <span class="keyword1">exp[</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">]</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> type_def type_safe_def
  <span class="keyword1"><span class="command">using</span></span> stamp_expr.simps<span class="main">(</span>3<span class="main">)</span> stamp_binary.simps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">sorry</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> uminus_intstamp_prop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type <span class="free">x</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"type <span class="keyword1">exp[</span><span class="main">-</span><span class="free">x</span><span class="main">]</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> type_def type_safe_def
  <span class="keyword1"><span class="command">using</span></span> stamp_expr.simps<span class="main">(</span>1<span class="main">)</span> stamp_unary.simps<span class="main">(</span>1<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Stamp.collapse<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Stamp.discI<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> type_def unfold_type unrestricted_stamp.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> assume_proof <span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type <span class="free">x</span> <span class="main">=</span> Integer"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"type_safe <span class="free">x</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rewrite_obligation <span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span><span class="free">y</span><span class="main">)</span> <span class="main">↦</span> <span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rewrite_obligation.simps 
  <span class="keyword1"><span class="command">unfolding</span></span> le_expr_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> allI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> type_def type_safe_def 
  <span class="keyword1"><span class="command">using</span></span> CanonicalizeAddProof CanonicalizeAdd.intros
  <span class="keyword1"><span class="command">sorry</span></span>
<span class="comment1">(*
proof (induction rule: evaltree.induct)
  fix m p
  have "is_IntegerStamp (stamp_expr ?lhs)"
    using assms unfolding type_def
    by (smt (z3) Stamp.collapse(1) Stamp.sel(1) add_intstamp_prop assms(1) stamp_expr.simps(1) stamp_unary.simps(1) uminus_intstamp_prop unfold_int_typesafe unfold_type unrestricted_stamp.simps(2))
  obtain v where lhs: "[m,p] ⊢ ?lhs ↦ v"
    using BinaryExprE evalDet sorry
  obtain v2 where rhs: "[m,p] ⊢ ?rhs ↦ v2"
    sorry
  then show "v = v2"
    sorry
  then show ?thesis
*)</span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"rewrite_obligation <span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span><span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> <span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">when</span> <span class="main">(</span>type <span class="free">x</span> <span class="main">=</span> Integer <span class="main">∧</span> type_safe <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">sorry</span></span>


<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>size <span class="keyword1">exp[</span><span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span><span class="free">y</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">(</span>size <span class="keyword1">exp[</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> size.simps<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>



<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">datatype</span></span> 'a <span class="entity">Rewrite</span> <span class="main">=</span>
  <span class="entity">Transform</span> <span class="keyword2"><span class="keyword">of</span></span> 'a * 'a <span class="main">|</span>
  <span class="entity">Conditional</span> <span class="keyword2"><span class="keyword">of</span></span> 'a * 'a * term <span class="main">|</span>
  <span class="entity">Sequential</span> <span class="keyword2"><span class="keyword">of</span></span> 'a Rewrite * 'a Rewrite <span class="main">|</span>
  <span class="entity">Transitive</span> <span class="keyword2"><span class="keyword">of</span></span> 'a Rewrite

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">rewrite</span> <span class="main">=</span>
  <span class="main">{</span>name<span class="main">:</span> string<span class="main">,</span> rewrite<span class="main">:</span> term <span class="entity">Rewrite</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">phase</span> <span class="main">=</span>
  <span class="main">{</span>name<span class="main">:</span> string<span class="main">,</span> rewrites<span class="main">:</span> <span class="entity">rewrite</span> list<span class="main">,</span> preconditions<span class="main">:</span> term list<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">phase_store</span> <span class="main">=</span> <span class="main">(</span>string list * <span class="main">(</span>string <span class="main">-&gt;</span> <span class="entity">phase</span> option<span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">phase_state</span> <span class="main">=</span>
  <span class="entity">NoPhase</span> <span class="keyword2"><span class="keyword">of</span></span> phase_store <span class="main">|</span>
  <span class="entity">InPhase</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">(</span>string * phase_store<span class="main">)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PhaseState</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> get<span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">phase_state</span>
  <span class="keyword1"><span class="keyword">val</span></span> add<span class="main">:</span> <span class="entity">rewrite</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> reset<span class="main">:</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> enter_phase<span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> exit_phase<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">RWList</span><span class="main">:</span> <span class="entity">PhaseState</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> <span class="entity">NoPhase</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_maps</span> <span class="main">(</span><span class="entity">left</span><span class="main">:</span> 'a list * <span class="main">(</span>'a <span class="main">-&gt;</span> 'b option<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">right</span><span class="main">:</span> 'a list * <span class="main">(</span>'a <span class="main">-&gt;</span> 'b option<span class="main">)</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">(</span>fst <span class="entity">left</span><span class="main">)</span> @ <span class="main">(</span>fst <span class="entity">right</span><span class="main">)</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span>snd <span class="entity">left</span><span class="main">)</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> <span class="main">(</span>snd <span class="entity">right</span><span class="main">)</span> <span class="entity">x</span> <span class="main">|</span>
    SOME <span class="entity">v</span> <span class="main">=&gt;</span> SOME <span class="entity">v</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">RewriteStore</span> <span class="main">=</span> Theory_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">phase_state</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> <span class="entity">empty</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> 
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="entity">NoPhase</span> <span class="entity">left_store</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">NoPhase</span> <span class="entity">right_store</span> <span class="main">=&gt;</span> <span class="entity">NoPhase</span> <span class="main">(</span><span class="entity">merge_maps</span> <span class="entity">left_store</span> <span class="entity">right_store</span><span class="main">)</span> <span class="main">|</span>
        <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">right_store</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="entity">merge_maps</span> <span class="entity">left_store</span> <span class="entity">right_store</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span>
      <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">left_store</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">NoPhase</span> <span class="entity">right_store</span> <span class="main">=&gt;</span> <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="entity">merge_maps</span> <span class="entity">left_store</span> <span class="entity">right_store</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span>
        <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">right_store</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="entity">merge_maps</span> <span class="entity">left_store</span> <span class="entity">right_store</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get</span> <span class="main">=</span> RewriteStore.get<span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">expand_phase</span> <span class="entity">rewrite</span> <span class="main">(</span><span class="entity">phase</span><span class="main">:</span> <span class="entity">phase</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">{</span>name <span class="main">=</span> <span class="main">(</span><span class="main">#</span>name <span class="entity">phase</span><span class="main">)</span><span class="main">,</span> rewrites <span class="main">=</span> cons <span class="entity">rewrite</span> <span class="main">(</span><span class="main">#</span>rewrites <span class="entity">phase</span><span class="main">)</span><span class="main">,</span> preconditions <span class="main">=</span> <span class="main">(</span><span class="main">#</span>preconditions <span class="entity">phase</span><span class="main">)</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_existing</span> <span class="entity">name</span> <span class="main">(</span><span class="entity">dom</span><span class="main">,</span> <span class="entity">map</span><span class="main">)</span> <span class="entity">rewrite</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">value</span> <span class="main">=</span> <span class="entity">map</span> <span class="entity">name</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">value</span> <span class="keyword2"><span class="keyword">of</span></span>
      NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"phase not in store"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span>
      SOME <span class="entity">v</span> <span class="main">=&gt;</span> <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="entity">dom</span><span class="main">,</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">id</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">expand_phase</span> <span class="entity">rewrite</span> <span class="entity">v</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">map</span> <span class="entity">id</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add</span> <span class="entity">t</span> <span class="entity">thy</span> <span class="main">=</span> RewriteStore.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">state</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">NoPhase</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"error"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span>
    <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">store</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">update_existing</span> <span class="entity">name</span> <span class="entity">store</span> <span class="entity">t</span>
  <span class="main">)</span> <span class="entity">thy</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reset</span> <span class="main">=</span> RewriteStore.put <span class="entity">empty</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">new_phase</span> <span class="entity">name</span> <span class="main">=</span> <span class="main">{</span>name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> rewrites <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span> <span class="main">:</span> <span class="entity">rewrite</span> list<span class="main">)</span><span class="main">,</span> preconditions <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span> <span class="main">:</span> term list<span class="main">)</span><span class="main">}</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">enter_phase</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="main">=</span> RewriteStore.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">state</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">NoPhase</span> <span class="main">(</span><span class="entity">dom</span><span class="main">,</span> <span class="entity">store</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="entity">name</span><span class="main">]</span> @ <span class="entity">dom</span><span class="main">,</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">id</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">name</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">new_phase</span> <span class="entity">name</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">store</span> <span class="entity">id</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span>
    <span class="entity">InPhase</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"optimization phase already established"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="main">)</span> <span class="entity">thy</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">exit_phase</span> <span class="entity">thy</span> <span class="main">=</span> RewriteStore.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">state</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">NoPhase</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"phase already exited"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">|</span>
    <span class="entity">InPhase</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">existing</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">NoPhase</span> <span class="entity">existing</span>
  <span class="main">)</span> <span class="entity">thy</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_to_rewrite</span> <span class="entity">term</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">term</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="main">(</span><span class="main">(</span><span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"CanonicalizationSyntax.Rewrite.Transform"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">lhs</span><span class="main">)</span> $ <span class="entity">rhs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Transform</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"CanonicalizationSyntax.Rewrite.Conditional"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> $ <span class="entity">lhs</span><span class="main">)</span> $ <span class="entity">rhs</span><span class="main">)</span> $ <span class="entity">cond</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Conditional</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="entity">cond</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"optimization is not a rewrite"</span><span class="main">,</span> <span class="main">[</span><span class="entity">term</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_to_term</span> <span class="entity">rewrite</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rewrite</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">Transform</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=&gt;</span> 
      <span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"CanonicalizationSyntax.Rewrite.Transform"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span> <span class="main">=&gt;</span> <span class="tfree">'a</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span>
    <span class="main">|</span> <span class="entity">Conditional</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="entity">cond</span><span class="main">)</span> <span class="main">=&gt;</span> 
      <span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"CanonicalizationSyntax.Rewrite.Conditional"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span> <span class="main">=&gt;</span> <span class="tfree">'a</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span> $ <span class="entity">cond</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"rewrite cannot be translated yet"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_to_obligation</span> <span class="entity">ctxt</span> <span class="entity">term</span> <span class="main">=</span>
  Syntax.check_prop <span class="entity">ctxt</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Trueprop<span class="antiquote">}</span></span> $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> rewrite_obligation<span class="antiquote">}</span></span> $ <span class="entity">term</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_to_termination</span> <span class="entity">rewrite</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rewrite</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">Transform</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>
      <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Trueprop<span class="antiquote">}</span></span> 
      $ <span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"Orderings.ord_class.less"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span><span class="antiquote">}</span></span><span class="main">)</span>
      $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> size<span class="antiquote">}</span></span> $ <span class="entity">rhs</span><span class="main">)</span> $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> size<span class="antiquote">}</span></span> $ <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="entity">Conditional</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="entity">condition</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>
      Const <span class="main">(</span><span class="inner_quoted">"Pure.imp"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"prop <span class="main">⇒</span> prop <span class="main">⇒</span> prop"</span><span class="antiquote">}</span></span><span class="main">)</span>
      $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Trueprop<span class="antiquote">}</span></span> $ <span class="entity">condition</span><span class="main">)</span>
      $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Trueprop<span class="antiquote">}</span></span> $ <span class="main">(</span>Const <span class="main">(</span><span class="inner_quoted">"Orderings.ord_class.less"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> bool"</span><span class="antiquote">}</span></span><span class="main">)</span>
      $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> size<span class="antiquote">}</span></span> $ <span class="entity">rhs</span><span class="main">)</span> $ <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> size<span class="antiquote">}</span></span> $ <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"rewrite termination generation not implemented"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_optimization</span> 
  <span class="main">(</span><span class="main">(</span><span class="entity">bind</span><span class="main">:</span> binding<span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">opt</span><span class="main">:</span> string<span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">opt</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rewrite</span> <span class="main">=</span> <span class="entity">term_to_rewrite</span> <span class="entity">term</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">obligation</span> <span class="main">=</span> <span class="entity">term_to_obligation</span> <span class="entity">ctxt</span> <span class="entity">term</span><span class="main">;</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">terminating</span> <span class="main">=</span> <span class="entity">rewrite_to_termination</span> <span class="entity">rewrite</span><span class="main">;</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">register</span> <span class="main">=</span> <span class="entity">RWList.add</span> <span class="main">{</span>name<span class="main">=</span>Binding.print <span class="entity">bind</span><span class="main">,</span> rewrite<span class="main">=</span><span class="entity">rewrite</span><span class="main">}</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">after_qed</span> <span class="main">_</span> <span class="entity">ctxt</span> <span class="main">=</span>
      Local_Theory.background_theory <span class="entity">register</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">Proof.theorem</span> NONE <span class="entity">after_qed</span> <span class="main">[</span><span class="main">[</span><span class="main">(</span><span class="entity">obligation</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">terminating</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">]</span> <span class="entity">ctxt</span>
  <span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parse_optimization_declaration</span> <span class="main">=</span>
  <span class="entity">Parse_Spec.thm_name</span> <span class="inner_quoted">":"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory_to_proof</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">optimization</span>›</span></span>
    <span class="inner_quoted">"define an optimization and open proof obligation"</span>
    <span class="main">(</span><span class="entity">parse_optimization_declaration</span>
     -- Parse.term
     &gt;&gt; <span class="entity">register_optimization</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">exit_phase</span> <span class="entity">thy</span> <span class="main">=</span>
  Local_Theory.background_theory <span class="main">(</span><span class="entity">RWList.exit_phase</span><span class="main">)</span> <span class="entity">thy</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">begin_phase</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="main">=</span>
  Proof_Context.init_global <span class="main">(</span><span class="entity">RWList.enter_phase</span> <span class="entity">name</span> <span class="entity">thy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span>
  <span class="entity">pretty_rewrite</span> <span class="entity">rewrite</span> <span class="main">=</span> Syntax.pretty_term <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">rewrite_to_term</span> <span class="entity">rewrite</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_optimizations</span> <span class="entity">rewrites</span> <span class="main">=</span> 
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_rule</span> <span class="entity">tact</span> <span class="main">=</span>
      Pretty.block <span class="main">[</span>
        Pretty.str <span class="main">(</span><span class="main">(</span><span class="main">#</span>name <span class="entity">tact</span><span class="main">)</span> ^ <span class="inner_quoted">": "</span><span class="main">)</span><span class="main">,</span>
        <span class="entity">pretty_rewrite</span> <span class="main">(</span><span class="main">#</span>rewrite <span class="entity">tact</span><span class="main">)</span>
      <span class="main">]</span><span class="main">;</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">[</span>Pretty.big_list <span class="inner_quoted">"optimizations:"</span> <span class="main">(</span>map <span class="entity">print_rule</span> <span class="entity">rewrites</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_phase</span> <span class="main">(</span><span class="entity">phase</span><span class="main">:</span> <span class="entity">phase</span> option<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">phase</span> <span class="keyword2"><span class="keyword">of</span></span>
    NONE <span class="main">=&gt;</span> <span class="main">[</span>Pretty.str <span class="inner_quoted">"no phase"</span><span class="main">]</span> <span class="main">|</span>
    SOME <span class="entity">phase</span> <span class="main">=&gt;</span>
  <span class="main">[</span>Pretty.str <span class="main">(</span><span class="inner_quoted">"phase: "</span> ^ <span class="main">(</span><span class="main">#</span>name <span class="entity">phase</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
  @ <span class="main">(</span><span class="entity">print_optimizations</span> <span class="main">(</span><span class="main">#</span>rewrites <span class="entity">phase</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_phase_state</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">RWList.get</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">thy</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">NoPhase</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span>Pretty.str <span class="inner_quoted">"not in a phase"</span><span class="main">]</span> <span class="main">|</span>
    <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="entity">dom</span><span class="main">,</span> <span class="entity">map</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">print_phase</span> <span class="main">(</span><span class="entity">map</span> <span class="entity">name</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_all_phases</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">RWList.get</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">of</span></span>
    <span class="entity">NoPhase</span> <span class="main">(</span><span class="entity">dom</span><span class="main">,</span> <span class="entity">store</span><span class="main">)</span> <span class="main">=&gt;</span> 
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">print</span><span class="antiquote">}</span></span></span></span></span></span></span></span> <span class="entity">dom</span><span class="main">;</span>
      <span class="keyword2"><span class="keyword">in</span></span> List.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">acc</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">print_phase</span> <span class="main">(</span><span class="entity">store</span> <span class="entity">name</span><span class="main">)</span> @ <span class="entity">acc</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">dom</span> <span class="keyword2"><span class="keyword">end</span></span> <span class="main">|</span>
    <span class="entity">InPhase</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="main">(</span><span class="entity">dom</span><span class="main">,</span> <span class="entity">store</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> List.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">acc</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">print_phase</span> <span class="main">(</span><span class="entity">store</span> <span class="entity">name</span><span class="main">)</span> @ <span class="entity">acc</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">dom</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">phase_theory_init</span> <span class="entity">name</span> <span class="entity">thy</span> <span class="main">=</span> 
  Local_Theory.init 
    <span class="main">{</span>background_naming <span class="main">=</span> Sign.naming_of <span class="entity">thy</span><span class="main">,</span>
        setup <span class="main">=</span> <span class="entity">begin_phase</span> <span class="entity">name</span><span class="main">,</span>
        conclude <span class="main">=</span> <span class="entity">exit_phase</span><span class="main">}</span>
    <span class="main">{</span>define <span class="main">=</span> <span class="entity">Generic_Target.define</span> <span class="entity">Generic_Target.theory_target_foundation</span><span class="main">,</span>
        notes <span class="main">=</span> <span class="entity">Generic_Target.notes</span> <span class="entity">Generic_Target.theory_target_notes</span><span class="main">,</span>
        abbrev <span class="main">=</span> <span class="entity">Generic_Target.abbrev</span> <span class="entity">Generic_Target.theory_target_abbrev</span><span class="main">,</span>
        declaration <span class="main">=</span> K <span class="entity">Generic_Target.theory_declaration</span><span class="main">,</span>
        theory_registration <span class="main">=</span> <span class="entity">Locale.add_registration_theory</span><span class="main">,</span>
        locale_dependency <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Not possible in instantiation target"</span><span class="main">,</span>
        pretty <span class="main">=</span> <span class="entity">print_phase_state</span><span class="main">}</span>
    <span class="entity">thy</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">phase</span>›</span></span> <span class="inner_quoted">"instantiate and prove type arity"</span>
   <span class="main">(</span>Parse.name --| Parse.begin
     &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">name</span> <span class="main">=&gt;</span> <span class="entity">Toplevel.begin_main_target</span> true <span class="main">(</span><span class="entity">phase_theory_init</span> <span class="entity">name</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>


<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_print_optimizations</span> <span class="entity">thy</span> <span class="main">=</span>
  <span class="main">(</span><span class="entity">print_all_phases</span> <span class="entity">thy</span> |&gt; Pretty.writeln_chunks<span class="main">)</span>


<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">command_keyword</span><span class="hidden">&gt;</span></span>‹<span class="keyword1">print_optimizations</span>›</span></span>
    <span class="inner_quoted">"print debug information for optimizations"</span>
    <span class="main">(</span>Scan.succeed
      <span class="main">(</span><span class="entity">Toplevel.keep</span> <span class="main">(</span><span class="entity">apply_print_optimizations</span> o <span class="entity">Toplevel.theory_of</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">RWList.reset</span>›</span>


<span class="comment1">(*
notation BinaryExpr ("_ ⊕<span class="hidden">⇩</span><sub>_</sub> _")

value "x ⊕<span class="hidden">⇩</span><sub>s</sub> y"
*)</span>
<span class="keyword1"><span class="command">phase</span></span> Canonicalization <span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*
optimization constant_fold:
  "(const(c<span class="hidden">⇩</span><sub>1</sub>) ⊕<span class="hidden">⇩</span><sub>x</sub> const(c<span class="hidden">⇩</span><sub>2</sub>)) ↦ (bin_eval c<span class="hidden">⇩</span><sub>1</sub> x c<span class="hidden">⇩</span><sub>2</sub>)"
*)</span>
<span class="keyword1"><span class="command">optimization</span></span> constant_add<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">e1</span> <span class="main">+</span> <span class="free">e2</span><span class="main">)</span> <span class="main">↦</span> <span class="free">r</span> <span class="keyword1">when</span> <span class="main">(</span><span class="free">e1</span> <span class="main">=</span> ConstantExpr <span class="free">v1</span> <span class="main">∧</span> <span class="free">e2</span> <span class="main">=</span> ConstantExpr <span class="free">v2</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">=</span> ConstantExpr <span class="main">(</span>intval_add <span class="free">v1</span> <span class="free">v2</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> le_expr_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> evaltree.ConstantExpr <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">optimization</span></span> constant_add<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>c1 <span class="main">+</span> c2<span class="main">)</span> <span class="main">↦</span> ConstantExpr <span class="main">(</span>intval_add <span class="free">val_c1</span> <span class="free">val_c2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> le_expr_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> evaltree.ConstantExpr <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">print_context</span></span>
<span class="keyword1"><span class="command">print_optimizations</span></span>

<span class="keyword1"><span class="command">optimization</span></span> constant_shift<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>c <span class="main">+</span> <span class="free">e</span><span class="main">)</span> <span class="main">↦</span> <span class="main">(</span><span class="free">e</span> <span class="main">+</span> c<span class="main">)</span> <span class="keyword1">when</span> <span class="main">(</span><span class="main">¬</span><span class="main">(</span>is_ConstantExpr <span class="free">e</span><span class="main">)</span> <span class="main">∧</span> type <span class="free">e</span> <span class="main">=</span> Integer<span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command">unfolding</span></span> rewrite_obligation.simps <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">optimization</span></span> neutral_zero<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">e</span> <span class="main">+</span> <span class="keyword1">const</span><span class="main">(</span><span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> <span class="free">e</span> <span class="keyword1">when</span> <span class="main">(</span>type <span class="free">e</span> <span class="main">=</span> Integer<span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(</span><span class="free">e1</span> <span class="main">-</span> <span class="free">e2</span><span class="main">)</span> <span class="main">+</span> <span class="free">e2</span> <span class="main">↦</span> <span class="free">e1</span>"</span><span class="antiquote">}</span></span>›</span>

<span class="keyword1"><span class="command">optimization</span></span> neutral_left_add_sub<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">e1</span> <span class="main">-</span> <span class="free">e2</span><span class="main">)</span> <span class="main">+</span> <span class="free">e2</span> <span class="main">↦</span> <span class="free">e1</span>"</span></span>
  <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">optimization</span></span> neutral_right_add_sub<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">e1</span> <span class="main">+</span> <span class="main">(</span><span class="free">e2</span> <span class="main">-</span> <span class="free">e1</span><span class="main">)</span> <span class="main">↦</span> <span class="free">e2</span>"</span></span>
  <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">optimization</span></span> add_ynegate<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span><span class="free">y</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> <span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">when</span> <span class="main">(</span>type <span class="free">x</span> <span class="main">=</span> Integer <span class="main">∧</span> type_safe <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">sorry</span></span>

<span class="keyword1"><span class="command">print_context</span></span>
<span class="keyword1"><span class="command">print_optimizations</span></span>



<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">print_context</span></span>
<span class="keyword1"><span class="command">print_optimizations</span></span>

<span class="keyword1"><span class="command">phase</span></span> DirectTranslationTest <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">optimization</span></span> AbsIdempotence<span class="main">:</span> <span class="quoted"><span class="quoted">"abs<span class="main">(</span>abs<span class="main">(</span><span class="free">e</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> abs<span class="main">(</span><span class="free">e</span><span class="main">)</span> <span class="keyword1">when</span> is_IntegerStamp <span class="main">(</span>stamp_expr <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnaryExpr abs_abs_is_abs stamp_implies_valid_value is_IntegerStamp_def unary_eval.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">optimization</span></span> AbsNegate<span class="main">:</span> <span class="quoted"><span class="quoted">"abs<span class="main">(</span><span class="main">-</span><span class="free">e</span><span class="main">)</span> <span class="main">↦</span> abs<span class="main">(</span><span class="free">e</span><span class="main">)</span> <span class="keyword1">when</span> is_IntegerStamp <span class="main">(</span>stamp_expr <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnaryExpr abs_neg_is_neg stamp_implies_valid_value is_IntegerStamp_def unary_eval.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> int_constants_valid<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_int_val <span class="free">val</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_value <span class="main">(</span>constantAsStamp <span class="free">val</span><span class="main">)</span> <span class="free">val</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">val</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">lemma</span></span> unary_eval_preserves_validity<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_int_val <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_value <span class="main">(</span>constantAsStamp <span class="main">(</span>unary_eval <span class="free">op</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>unary_eval <span class="free">op</span> <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">op</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid intval_abs.simps<span class="main">(</span>1<span class="main">)</span> is_int_val.simps<span class="main">(</span>1<span class="main">)</span> unary_eval.simps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid intval_negate.simps<span class="main">(</span>1<span class="main">)</span> is_int_val.simps<span class="main">(</span>1<span class="main">)</span> unary_eval.simps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid intval_not.simps<span class="main">(</span>1<span class="main">)</span> is_int_val.simps<span class="main">(</span>1<span class="main">)</span> unary_eval.simps<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid is_int_val.simps<span class="main">(</span>1<span class="main">)</span> unary_eval.simps<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">op</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid intval_abs.simps<span class="main">(</span>2<span class="main">)</span> is_int_val.simps<span class="main">(</span>2<span class="main">)</span> unary_eval.simps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid intval_negate.simps<span class="main">(</span>2<span class="main">)</span> is_int_val.simps<span class="main">(</span>2<span class="main">)</span> unary_eval.simps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid intval_not.simps<span class="main">(</span>2<span class="main">)</span> is_int_val.simps<span class="main">(</span>2<span class="main">)</span> unary_eval.simps<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">sorry</span></span> <span class="comment1">(* WARNING: TODO: WARNING: a whole bunch of unary operations aren't implemented making this false *)</span>

<span class="keyword1"><span class="command">optimization</span></span> UnaryConstantFold<span class="main">:</span> <span class="quoted"><span class="quoted">"UnaryExpr <span class="free">op</span> c <span class="main">↦</span> ConstantExpr <span class="main">(</span>unary_eval <span class="free">op</span> <span class="free">val_c</span><span class="main">)</span> <span class="keyword1">when</span> is_int_val <span class="free">val_c</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> int_constants_valid<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> evaltree.ConstantExpr int_constants_valid unary_eval_preserves_validity <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">optimization</span></span> AndEqual<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">&amp;</span> <span class="free">x</span><span class="main">)</span> <span class="main">↦</span> <span class="free">x</span> <span class="keyword1">when</span> is_IntegerStamp <span class="main">(</span>stamp_expr <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> BinaryExprE CanonicalizeAndProof and_same<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> size_gt_0<span class="main">)</span>

<span class="keyword1"><span class="command">optimization</span></span> AndShiftConstantRight<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>ConstantExpr <span class="free">x</span><span class="main">)</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="main">↦</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span>ConstantExpr <span class="free">x</span><span class="main">)</span> <span class="keyword1">when</span> <span class="main">~</span><span class="main">(</span>is_ConstantExpr <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> ccfv_threshold<span class="main"><span class="main">)</span></span> BinaryExprE bin_eval.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> evaltree.simps intval_add_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps <span class="keyword1"><span class="command">using</span></span> nonconstants_gt_one <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(*
optimization AndRightFallthrough: "x &amp; y ↦ y when (canBeZero x.stamp &amp; canBeOne y.stamp) = 0" sorry
optimization AndLeftFallthrough: "x &amp; y ↦ x when (canBeZero y.stamp &amp; canBeOne x.stamp) = 0" sorry
*)</span>

<span class="keyword1"><span class="command">lemma</span></span> neutral_and<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_value <span class="main">(</span>IntegerStamp <span class="numeral">32</span> <span class="free">lox</span> <span class="free">hix</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bin_eval BinAnd <span class="free">x</span> <span class="main">(</span>IntVal32 <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms bin_eval.simps<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">optimization</span></span> AndNeutral<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">&amp;</span> <span class="main">(</span><span class="keyword1">const</span> <span class="main">(</span><span class="keyword1">NOT</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> <span class="free">x</span> <span class="keyword1">when</span> <span class="main">(</span>stamp_expr <span class="free">x</span> <span class="main">=</span> IntegerStamp <span class="numeral">32</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">using</span></span> neutral_and stamp_implies_valid_value <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  
<span class="keyword1"><span class="command">optimization</span></span> ConditionalEqualBranches<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">b</span> <span class="main">?</span> <span class="free">v</span> <span class="main">:</span> <span class="free">v</span><span class="main">)</span> <span class="main">↦</span> <span class="free">v</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">optimization</span></span> ConditionalEqualIsRHS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">==</span> <span class="free">y</span><span class="main">)</span> <span class="main">?</span> <span class="free">x</span> <span class="main">:</span> <span class="free">y</span><span class="main">)</span> <span class="main">↦</span> <span class="free">y</span> <span class="keyword1">when</span> <span class="main">(</span>type <span class="free">x</span> <span class="main">=</span> Integer <span class="main">∧</span> type_safe <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> del_insts<span class="main"><span class="main">)</span></span> BinaryExprE CanonicalizeConditionalProof ConditionalExprE cond_eq type_safe_def unfold_type<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="comment1">(*
optimization ConditionalEliminateKnownLess: "(x &lt; y ? x : y) ↦ x when (x.stamp.upper &lt;= y.stamp.lower)" sorry
optimization ConditionalEliminateKnownLess: "(x &lt; y ? y : x) ↦ y when (x.stamp.upper &lt;= y.stamp.lower)" sorry
*)</span>

<span class="keyword1"><span class="command">lemma</span></span> bool_is_int_val<span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_int_val <span class="main">(</span>bool_to_val <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bool_to_val.simps is_int_val.simps <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> bin_eval_preserves_validity<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"int_and_equal_bits <span class="free">c1</span> <span class="free">c2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valid_value <span class="main">(</span>constantAsStamp <span class="main">(</span>bin_eval <span class="free">op</span> <span class="free">c1</span> <span class="free">c2</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>bin_eval <span class="free">op</span> <span class="free">c1</span> <span class="free">c2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c1</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">c2</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">op</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid bool_is_int_val
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid bool_is_int_val
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid bool_is_int_val
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">op</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>  
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid bool_is_int_val
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid bool_is_int_val
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> int_constants_valid bool_is_int_val
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> IRTreeEval.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> Values.bool_to_val.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">optimization</span></span> BinaryFoldConstant<span class="main">:</span> <span class="quoted"><span class="quoted">"BinaryExpr <span class="free">op</span> <span class="main">(</span>ConstantExpr <span class="free">e1</span><span class="main">)</span> <span class="main">(</span>ConstantExpr <span class="free">e2</span><span class="main">)</span> <span class="main">↦</span> ConstantExpr <span class="main">(</span>bin_eval <span class="free">op</span> <span class="free">e1</span> <span class="free">e2</span><span class="main">)</span> <span class="keyword1">when</span> int_and_equal_bits <span class="free">e1</span> <span class="free">e2</span> "</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">using</span></span> evaltree.BinaryExpr evaltree.ConstantExpr stamp_implies_valid_value
  <span class="keyword1"><span class="command">using</span></span> bin_eval_preserves_validity 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span> <span class="keyword1"><span class="command">using</span></span> nonconstants_gt_one
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">optimization</span></span> AddShiftConstantRight<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>ConstantExpr <span class="free">x</span><span class="main">)</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="main">↦</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span>ConstantExpr <span class="free">x</span><span class="main">)</span> <span class="keyword1">when</span> <span class="main">~</span><span class="main">(</span>is_ConstantExpr <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> del_insts<span class="main"><span class="main">)</span></span> BinaryExprE bin_eval.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> evaltree.simps intval_add_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps <span class="keyword1"><span class="command">using</span></span> nonconstants_gt_one <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="comment1">(*
optimization RedundantSubAdd: "isAssociative + =&gt; (a - b) + b ↦ a" sorry
optimization RedundantAddSub: "isAssociative + =&gt; (b + a) - b ↦ a" sorry
*)</span>
<span class="keyword1"><span class="command">lemma</span></span> neutral_add<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"valid_value <span class="main">(</span>IntegerStamp <span class="numeral">32</span> <span class="free">lox</span> <span class="free">hix</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bin_eval BinAdd <span class="free">x</span> <span class="main">(</span>IntVal32 <span class="main">(</span><span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms bin_eval.simps<span class="main">(</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">optimization</span></span> AddNeutral<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">e</span> <span class="main">+</span> <span class="main">(</span><span class="keyword1">const</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> <span class="free">e</span> <span class="keyword1">when</span> <span class="main">(</span>stamp_expr <span class="free">e</span> <span class="main">=</span> IntegerStamp <span class="numeral">32</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">using</span></span> neutral_add stamp_implies_valid_value 
  <span class="keyword1"><span class="command">using</span></span> evaltree.BinaryExpr evaltree.ConstantExpr
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> BinaryExprE ConstantExprE<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> intval_negateadd_equals_sub_left<span class="main">:</span> <span class="quoted"><span class="quoted">"bin_eval BinAdd <span class="main">(</span>unary_eval UnaryNeg <span class="free">e</span><span class="main">)</span> <span class="free">y</span> <span class="main">=</span> bin_eval BinSub <span class="free">y</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> intval_negateadd_equals_sub_right<span class="main">:</span> <span class="quoted"><span class="quoted">"bin_eval BinAdd <span class="free">x</span> <span class="main">(</span>unary_eval UnaryNeg <span class="free">e</span><span class="main">)</span> <span class="main">=</span> bin_eval BinSub <span class="free">x</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">optimization</span></span> AddLeftNegateToSub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">e</span> <span class="main">+</span> <span class="free">y</span> <span class="main">↦</span> <span class="free">y</span> <span class="main">-</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">using</span></span> intval_negateadd_equals_sub_left
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> BinaryExpr BinaryExprE UnaryExprE<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">optimization</span></span> AddRightNegateToSub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">+</span> <span class="main">-</span><span class="free">e</span> <span class="main">↦</span> <span class="free">x</span> <span class="main">-</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command">using</span></span> intval_negateadd_equals_sub_right
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> BinaryExpr BinaryExprE UnaryExprE<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">optimization</span></span> AddShiftConstantRight<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>ConstantExpr <span class="free">x</span><span class="main">)</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span> <span class="main">↦</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span>ConstantExpr <span class="free">x</span><span class="main">)</span> <span class="keyword1">when</span> <span class="main">~</span> <span class="main">(</span>is_ConstantExpr <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> BinaryExpr BinaryExprE bin_eval.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> intval_add_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps <span class="keyword1"><span class="command">using</span></span> nonconstants_gt_one <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">optimization</span></span> MulEliminator<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="keyword1">const</span><span class="main">(</span><span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> <span class="keyword1">const</span><span class="main">(</span><span class="main">0</span><span class="main">)</span> <span class="keyword1">when</span> <span class="main">(</span>stamp_expr <span class="free">x</span> <span class="main">=</span> IntegerStamp <span class="numeral">32</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> BinaryExprE ConstantExprE annihilator_rewrite_helper<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> bin_eval.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> stamp_implies_valid_value<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> size_gt_0<span class="main">)</span>

<span class="keyword1"><span class="command">optimization</span></span> MulNeutral<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="keyword1">const</span><span class="main">(</span><span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">↦</span> <span class="free">x</span> <span class="keyword1">when</span> <span class="main">(</span>stamp_expr <span class="free">x</span> <span class="main">=</span> IntegerStamp <span class="numeral">32</span> <span class="free">l</span> <span class="free">u</span><span class="main">)</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> BinaryExprE ConstantExprE bin_eval.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> neutral_rewrite_helper<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> stamp_implies_valid_value<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> size.simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(*
optimization MulNegate: "(x * const (-1) ) ↦ -x when (stamp_expr x = IntegerStamp 32 l u)"
  apply simp
  apply (metis BinaryExprE ConstantExprE bin_eval.simps(2) neutral_rewrite_helper(1) stamp_implies_valid_value)
  unfolding size.simps by simp
*)</span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">3</span><span class="main">::</span><span class="numeral">32</span> word<span class="main">)</span> <span class="keyword1">mod</span> <span class="numeral">32</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≥</span> <span class="main">0</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">base</span> <span class="main">⟹</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">base</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">sledgehammer</span></span>
  <span class="keyword1"><span class="command">using</span></span> mod_less <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> word_mod_less<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>len<span class="main">)</span> word<span class="main">)</span> <span class="main">&lt;</span> <span class="free">base</span> <span class="main">⟹</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">base</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mod_less not_le unat_arith_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> unat_arith_simps<span class="main"><span class="main">(</span></span>7<span class="main"><span class="main">)</span></span> unat_mono word_le_less_eq<span class="main">)</span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">4294967298</span><span class="main">::</span><span class="numeral">32</span> word"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> shift_equality<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">v1</span><span class="main">::</span><span class="numeral">32</span> word<span class="main">)</span> <span class="main">&lt;&lt;</span> unat <span class="main">(</span><span class="main">(</span><span class="free">v2</span><span class="main">::</span><span class="numeral">32</span> word<span class="main">)</span> <span class="keyword1">mod</span> <span class="numeral">32</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">v1</span> <span class="main">*</span> <span class="main">(</span><span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>unat <span class="free">v2</span><span class="main">)</span><span class="main">)</span><span class="main">::</span><span class="numeral">32</span> word<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"size_class.size <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>unat <span class="free">v2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">32</span>"</span></span> <span class="keyword1"><span class="command">sorry</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>unat <span class="free">v2</span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="numeral">32</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> uint_range_size <span class="keyword1"><span class="command">sorry</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unat <span class="free">v2</span> <span class="main">&lt;</span> <span class="numeral">32</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> nat_power_less_imp_less zero_less_numeral <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="numeral">2</span> <span class="main">^</span> unat <span class="free">v2</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="numeral">32</span>›</span></span> numeral_Bit0 power2_eq_square power_add <span class="keyword1"><span class="command">sorry</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="comment1">(*
proof (cases "v2 &lt; 32")
  case True
  have "v2 mod 32 = v2"
    using True
    by (simp add: word_mod_less)
  then show ?thesis
    by simp
next
  case False
  obtain powered where powered_def: "(powered::32 word) = 2 ^ (unat v2)"
    by auto
  have "powered &lt; (2 ^ 32)"
    sorry
  then have "powered mod (2 ^ 32) = powered"
    using word_mod_less
    by blast
  then have "v2 mod 32 = v2"
    unfolding powered_def sorry
  then show ?thesis unfolding powered_def sorry
qed

lemma intval_shift_equality:
  shows "intval_mul (IntVal32 x) (IntVal32 (2^(unat j))) = intval_left_shift (IntVal32 x) (IntVal32 j)"
  unfolding intval_mul.simps intval_left_shift.simps
  by (simp add: shift_equality)

lemma bin_shift_equality:
  "bin_eval BinMul (IntVal32 x) (IntVal32 (2^(unat j))) = bin_eval BinLeftShift (IntVal32 x) (IntVal32 j)"
  using intval_shift_equality by simp

optimization MulPower2: "(x * const(2^(unat j))) ↦ x &lt;&lt; const(j) when (stamp_expr x = IntegerStamp 32 l u)"
   apply simp
  using BinaryExprE ConstantExprE bin_eval.simps(2,7) stamp_implies_valid_value intval_shift_equality
  sorry
*)</span>

<span class="keyword1"><span class="command">print_context</span></span>
<span class="keyword1"><span class="command">print_optimizations</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">print_optimizations</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</body>

</html>